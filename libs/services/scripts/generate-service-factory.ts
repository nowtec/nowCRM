import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SERVICES_DIR = path.resolve(__dirname, "../src/services");
const FACTORY_PATH = path.join(SERVICES_DIR, "common/factory.ts");
const IGNORED_DIRECTORIES = new Set(["common"]);

type ServiceEntry = {
  identifier: string;
  importPath: string;
  kind: "base" | "custom";
};

const SERVICE_EXPORT_REGEX = /export const\s+(\w+)\s*=\s*new\s+/;

async function collectServiceFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];

  for (const entry of entries) {
    const entryPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (IGNORED_DIRECTORIES.has(entry.name)) {
        continue;
      }

      const subFiles = await collectServiceFiles(entryPath);
      files.push(...subFiles);
    } else if (
      entry.isFile() &&
      entry.name.endsWith(".service.ts") &&
      entry.name !== "factory.ts"
    ) {
      files.push(entryPath);
    }
  }

  return files;
}

async function extractServiceEntry(servicePath: string): Promise<ServiceEntry | null> {
  const content = await fs.readFile(servicePath, "utf8");
  const match = content.match(SERVICE_EXPORT_REGEX);

  if (!match) {
    console.warn(`Skipping ${servicePath} â€“ no exported service const found.`);
    return null;
  }

  const identifier = match[1];
  const relativePath = path
    .relative(path.dirname(FACTORY_PATH), servicePath)
    .replace(/\.(ts|tsx)$/, "")
    .replace(/\\/g, "/");

  const importPath = relativePath.startsWith(".")
    ? relativePath
    : `./${relativePath}`;

  const kind = /extends\s+BaseService/.test(content) ? "base" : "custom";

  return {
    identifier,
    importPath,
    kind,
  };
}
 
function createFactoryContent(entries: ServiceEntry[]): string {
  const sortedEntries = entries.sort((a, b) =>
    a.identifier.localeCompare(b.identifier)
  );

  const importLines = sortedEntries
    .map(({ identifier, importPath }) => `import { ${identifier} } from '${importPath}';`)
    .join("\n");

  const baseEntries = sortedEntries.filter((entry) => entry.kind === "base");
  const customEntries = sortedEntries.filter((entry) => entry.kind === "custom");

  const baseServiceNamesArray = baseEntries
    .map(({ identifier }) => `  '${identifier}',`)
    .join("\n");

  const customServiceNamesArray = customEntries
    .map(({ identifier }) => `  '${identifier}',`)
    .join("\n");

  const allServiceNamesArray = sortedEntries
    .map(({ identifier }) => `  '${identifier}',`)
    .join("\n");

  const baseServicesObject = baseEntries
    .map(({ identifier }) => `  ${identifier},`)
    .join("\n");

  const customServicesObject = customEntries
    .map(({ identifier }) => `  ${identifier},`)
    .join("\n");

  const baseSection = baseEntries.length
    ? `const BASE_SERVICE_NAMES = [\n${baseServiceNamesArray}\n] as const;\n\nexport type BaseServiceName = (typeof BASE_SERVICE_NAMES)[number];\n\nconst baseServices: Record<BaseServiceName, BaseService<unknown, unknown>> = {\n${baseServicesObject}\n};\n`
    : `export type BaseServiceName = never;\n\nconst baseServices: Record<BaseServiceName, BaseService<unknown, unknown>> = {} as Record<BaseServiceName, BaseService<unknown, unknown>>;\n`;

  const customSection = customEntries.length
    ? `const CUSTOM_SERVICE_NAMES = [\n${customServiceNamesArray}\n] as const;\n\nexport type CustomServiceName = (typeof CUSTOM_SERVICE_NAMES)[number];\n\nconst customServices = {\n${customServicesObject}\n} as const;\n`
    : `export type CustomServiceName = never;\n\nconst customServices = {} as const;\n`;

  return `// AUTO-GENERATED BY scripts/generate-service-factory.ts. DO NOT EDIT MANUALLY.\nimport type BaseService from './base.service';\n${importLines}\n\n${baseSection}\n${customSection}\nconst SERVICE_NAMES = [\n${allServiceNamesArray}\n] as const;\n\nexport type ServiceName = (typeof SERVICE_NAMES)[number];\n\nexport function getService<T extends BaseServiceName>(serviceName: T): BaseService<unknown, unknown>;
export function getService<T extends CustomServiceName>(serviceName: T): (typeof customServices)[T];
export function getService(serviceName: ServiceName) {
  if (serviceName in baseServices) {
    return baseServices[serviceName as BaseServiceName];
  }

  const customService = customServices[serviceName as CustomServiceName];

  if (!customService) {
    throw new Error(\`Unknown service: \${serviceName}\`);
  }

  return customService;
}

export const ServiceFactory = {
  getService,
} as const;\n`;
}

async function generateFactory(): Promise<void> {
  const serviceFiles = await collectServiceFiles(SERVICES_DIR);
  const entries: ServiceEntry[] = [];

  for (const file of serviceFiles) {
    const entry = await extractServiceEntry(file);
    if (entry) {
      entries.push(entry);
    }
  }

  if (entries.length === 0) {
    console.warn("No services found. Skipping factory generation.");
    return;
  }

  const content = createFactoryContent(entries);
  await fs.writeFile(FACTORY_PATH, content, "utf8");
  console.log(`Generated factory with ${entries.length} services.`);
}

generateFactory().catch((error) => {
  console.error("Failed to generate service factory:", error);
  process.exit(1);
});


